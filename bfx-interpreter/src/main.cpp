#include "bfint.hpp"

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

void printHelp(std::string const& progName)
{
    std::cout
        << "Usage: " << progName << " [options] <target(.bf)>\n"
        << "Options:\n"
        << "-h, --help          Display this text.\n"
        << "-t, --type [Type]   Specify the number of bytes per BF-cell, "
           "where [Type] is one of\n"
           "                    int8, int16 and int32 (int8 by default).\n"
        << "-n [N]              Specify the number of cells (30,000 by "
           "default).\n"
        << "--test [file]       Run the tests specified by the file "
           "(generated by bfx --test)\n"
        << "--random            Enable Random Brainf*ck extension (support "
           "?-symbol)\n"
        << "--rand-max [N]      Specifiy maximum value returned by RNG.\n"
        << "                      Defaults to maximum supported value of "
           "cell-type\n"
        << "--no-random-warning Don't display a warning when ? occurs "
           "without running --random.\n\n"
        << "Example: " << progName
        << " --random -t int16 -o output.txt program.bf\n";
}

Options parseCmdLine(std::vector<std::string> const& args)
{
    Options opt;

    size_t idx = 1;
    while (idx < args.size())
    {
        if (args[idx] == "-h" || args[idx] == "--help")
        {
            opt.err = 1;
            return opt;
        }

        else if (args[idx] == "-t" || args[idx] == "--type")
        {
            if (idx == args.size() - 1)
            {
                std::cerr << "ERROR: No argument passed to option \'-t\'.\n";
                opt.err = 1;
                return opt;
            }

            static std::map<std::string, CellType> const getType{
                {"int8", CellType::INT8},
                {"int16", CellType::INT16},
                {"int32", CellType::INT32}
            };

            auto tolower = [](std::string str) -> std::string
            {
                std::transform(
                    str.begin(),
                    str.end(),
                    str.begin(),
                    [](unsigned char c)
                    {
                        return std::tolower(c);
                    }
                );
                return str;
            };

            std::string arg = tolower(args[idx + 1]);
            try
            {
                opt.cellType = getType.at(arg);
                idx += 2;
            }
            catch (std::out_of_range const&)
            {
                std::cerr
                    << "ERROR: Invalid argument passed to option \'-t\'\n";
                opt.err = 1;
                return opt;
            }
        }
        else if (args[idx] == "-n")
        {
            if (idx == args.size() - 1)
            {
                std::cerr << "ERROR: No argument passed to option \'-n\'.\n";
                opt.err = 1;
                return opt;
            }
            try
            {
                opt.tapeLength = std::stoi(args[idx + 1]);
                if (opt.tapeLength <= 0)
                {
                    std::cerr
                        << "ERROR: tape length must be a positive integer.\n";
                    opt.err = 1;
                    return opt;
                }
                idx += 2;
            }
            catch (std::invalid_argument const&)
            {
                std::cerr
                    << "ERROR: Invalid argument passed to option \'-n\'\n";
                opt.err = 1;
                return opt;
            }
        }
        else if (args[idx] == "--test")
        {
            if (idx == args.size() - 1)
            {
                std::cerr
                    << "ERROR: No filename passed to option \'--test\'.\n";
                return opt;
            }

            opt.testFile = args[idx + 1];
            idx += 2;
        }
        else if (args[idx] == "--random")
        {
            opt.randomEnabled = true;
            ++idx;
        }
        else if (args[idx] == "--rand-max")
        {
            if (idx == args.size() - 1)
            {
                std::cerr
                    << "ERROR: No argument passed to option '--rand-max'.\n";
                opt.err = 1;
                return opt;
            }
            try
            {
                opt.randMax = std::stoi(args[idx + 1]);
                if (opt.randMax <= 0)
                {
                    std::cerr
                        << "ERROR: rand-max must be a positive integer.\n";
                    opt.err = 1;
                    return opt;
                }

                idx += 2;
            }
            catch (std::invalid_argument const&)
            {
                std::cerr
                    << "ERROR: Invalid argument passed to option --rand-max\n";
                opt.err = 1;
                return opt;
            }
        }
        else if (args[idx] == "--no-random-warning")
        {
            opt.randomWarningEnabled = false;
            ++idx;
        }

        else if (idx == args.size() - 1)
        {
            opt.bfFile = args.back();
            break;
        }
        else
        {
            std::cerr << "Unknown option " << args[idx] << ".\n";
            opt.err = 1;
            return opt;
        }
    }

    if (idx > (args.size() - 1))
    {
        std::cerr << "ERROR: No input (.bf) file specified.\n";
        opt.err = 1;
        return opt;
    }

    return opt;
}

int main(int argc, char** argv)
try
{
    Options opt = parseCmdLine(std::vector<std::string>(argv, argv + argc));
    if (opt.err == 1)
    {
        printHelp(argv[0]);
        return 1;
    }

    if (opt.randMax > 0 && !opt.randomEnabled)
    {
        std::cerr
            << "Warning: a value for rand-max was specified but the random "
               "extension was not "
               "enabled. Use --random to enable this feature.\n";
    }

    BFInterpreter bfint(opt);
    return bfint.run();
}
catch (std::string const& msg)
{
    std::cerr << msg << '\n';
}
